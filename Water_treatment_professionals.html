<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Water Treatment Professionals</title>
  <link rel="stylesheet" href="https://js.arcgis.com/4.33/esri/themes/light/main.css" />
  <script src="https://js.arcgis.com/4.32/"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100vh;
      width: 100vw;
      box-sizing: border-box;
      overflow: hidden;
    }
    #mainAppContainer {
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: 100vw;
    }
    #mainContent {
      flex: 1;
      display: flex;
      flex-direction: row;
      min-height: 0;
      min-width: 0;
    }
    #viewDiv {
      flex: 1;
      min-width: 0;
      min-height: 0;
      position: relative;
      z-index: 1;
    }
    #manipulatorPane {
      width: 420px;
      max-width: 90vw;
      background: #f5f2e6;
      border-left: 1px solid #ccc;
      box-shadow: -2px 0 6px rgba(0,0,0,0.04);
      display: flex;
      flex-direction: column;
      align-items: stretch;
      padding: 0;
      z-index: 10;
      min-width: 300px;
      transition: width 0.2s;
      overflow-y: auto;
    }
    #manipulatorHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      border-bottom: 1px solid #e0e0e0;
    }
    #manipulatorContent {
      padding: 18px 16px;
      color: #222;
      font-size: 15px;
    }
    #manipulatorCloseBtn {
      background: none;
      border: none;
      font-size: 22px;
      color: #888;
      cursor: pointer;
    }
    #toolbox {
      display: flex;
      flex-direction: row;
      align-items: center;
      background: #034d46;
      padding: 4px 8px;
      gap: 8px;
      z-index: 10;
      height: 44px;
      min-height: 36px;
      max-height: 48px;
      box-shadow: 0 2px 4px rgba(23, 100, 36, 0.788);
      position: relative;
    }
  </style>
</head>
<body>
  <div id="mainAppContainer" style="display: flex; flex-direction: column; height: 100vh; width: 100vw;">
  <div id="toolbox">
      <div style="position: relative;">
        <button id="layersBtn" style="padding: 6px 14px; background: #fff; color: #034d46; border-radius: 4px; border: none; font-weight: bold; cursor: pointer;">Layers ▼</button>
        <div id="layersDropdown" style="display: none; position: absolute; top: 36px; left: 0; background: #fff; border: 1px solid #ccc; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); min-width: 220px; z-index: 100; padding: 8px 12px;">
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
            <input type="checkbox" id="chkProfessionals" checked>
            Water Treatment Professionals
          </label>
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
            <input type="checkbox" id="chkBlueTriangles">
            AWT + Water treaters
          </label>
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
            <input type="checkbox" id="chkYellowTriangles">
            Companies for linked-in search
          </label>
          <label style="display: flex; align-items: center; gap: 8px;">
            <input type="checkbox" id="chkCounties">
            US Counties
          </label>
  </div>
  </div>
      <div style="position: relative;">
        <button id="legendBtn" style="padding: 6px 14px; background: #fff; color: #034d46; border-radius: 4px; border: none; font-weight: bold; cursor: pointer;">Legend</button>
      </div>
      <div style="position: relative;">
        <button id="filterBtn" style="padding: 6px 14px; background: #fff; color: #034d46; border-radius: 4px; border: none; font-weight: bold; cursor: pointer;">Filter</button>
      </div>
      <div style="position: relative;">
        <button id="selectBtn" style="padding: 6px 14px; background: #fff; color: #034d46; border-radius: 4px; border: none; font-weight: bold; cursor: pointer;">Select ▼</button>
        <div id="selectDropdown" style="display: none; position: absolute; top: 36px; left: 0; background: #fff; border: 1px solid #ccc; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); min-width: 120px; z-index: 100; padding: 6px 0;">
          <div class="select-option" data-mode="square" style="padding: 6px 16px; cursor: pointer;">Square</div>
          <div class="select-option" data-mode="lasso" style="padding: 6px 16px; cursor: pointer;">Lasso</div>
        </div>
      </div>
      <div style="position: relative; flex: 1; max-width: 400px;">
        <input id="searchBox" type="text" placeholder="Search all layers..." style="width: 100%; padding: 6px 12px; border-radius: 4px; border: 1px solid #ccc; font-size: 15px;" autocomplete="off" />
        <div id="searchSuggestions" style="display: none; position: absolute; top: 36px; left: 0; right: 0; background: #fff; border: 1px solid #ccc; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 200; max-height: 320px; overflow-y: auto;"></div>
      </div>
    </div>
    <div id="mainContent" style="flex: 1; display: flex; flex-direction: row; min-height: 0; min-width: 0;">
      <div id="viewDiv" style="flex: 1; min-width: 0; min-height: 0; position: relative; z-index: 1;"></div>
      <div id="manipulatorPane" style="width: 420px; max-width: 90vw; background: #f5f2e6; border-left: 1px solid #ccc; box-shadow: -2px 0 6px rgba(0,0,0,0.04); display: none; flex-direction: column; align-items: stretch; padding: 0; z-index: 10; min-width: 300px; transition: width 0.2s; overflow-y: auto;">
        <div id="manipulatorHeader" style="display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; border-bottom: 1px solid #e0e0e0;">
          <span style="font-weight: bold; font-size: 17px; color: #1a3a5b;">Manipulator Pane</span>
          <button id="manipulatorCloseBtn" style="background: none; border: none; font-size: 22px; color: #888; cursor: pointer;">&times;</button>
        </div>
        <div id="manipulatorContent" style="padding: 18px 16px; color: #222; font-size: 15px;">
          <div id="legendContent" style="color:#222;"></div>
        </div>
      </div>
    </div>
  </div>
  <script>
    let professionalsData = [];
    let blueTrianglesData = [];
    let yellowTrianglesData = [];


    require([
      "esri/Map", "esri/views/MapView", "esri/layers/FeatureLayer", "esri/layers/GeoJSONLayer", "esri/Graphic"
    ], function (
      EsriMap, MapView, FeatureLayer, GeoJSONLayer, Graphic
    ) {
      let map, view;
      let professionalsLayerRef = null;
      let countiesLayerRef = null;
      let blueTrianglesLayerRef = null;
      let yellowTrianglesLayerRef = null;

      const countiesGeoJsonUrl = "https://raw.githubusercontent.com/Link0923/Water_Treatment_Data/main/US_Counties.geojson";
      const countiesLayer = new GeoJSONLayer({
        url: countiesGeoJsonUrl,
        title: "US Counties",
        opacity: 1,
        minScale: 15000000,
        renderer: {
          type: "simple",
          symbol: {
            type: "simple-fill",
            color: [0, 0, 0, 0],
            outline: { color: "#000000", width: 1 }
          }
        },
        labelingInfo: [
          {
            minScale: 4000000,
            labelExpressionInfo: { expression: '$feature.FIPS' },
            symbol: {
              type: "text",
              color: "#222",
              haloColor: "orange",
              haloSize: "1.5px",
              font: { family: "Arial", size: 12, weight: "bold" }
            },
            labelPlacement: "always-horizontal"
          }
        ],
        popupTemplate: {
          title: "{NAME}",
          content: "County: {County Name}<br>FIPS: {5-digit FIPS Code}"
        }
      });
      countiesLayer.visible = false;
      countiesLayerRef = countiesLayer;

      map = new EsriMap({ basemap: "topo-vector" });
      view = new MapView({ container: "viewDiv", map: map, center: [-95.671, 39.049], zoom: 5 });
      map.add(countiesLayer, 0);

      async function updateCountyShading(professionals, countiesLayer) {
        const targetRoles = [
          "Sales and Account Management",
          "Field Service and Water Treatment"
        ];
        const countyCounts = {};
        professionals.forEach(feature => {
          const attrs = feature.attributes;
          const role = attrs["Role_Category"] || attrs["Role Category"] || "";
          const fips = attrs["FIPS"] || attrs["5_digit_FIPS_Code"] || attrs["FIPS_Code"] || attrs["fips"] || "";
          if (targetRoles.includes(role) && fips) {
            countyCounts[fips] = (countyCounts[fips] || 0) + 1;
          }
        });
        const counts = Object.values(countyCounts);
        const minCount = Math.min(...counts, 0);
        const maxCount = Math.max(...counts, 1);
        const colorRamp = [
          [230, 210, 255],
          [120, 0, 180]
        ];
        function interpolateColor(val, min, max, color1, color2) {
          const t = (max === min) ? 0 : (val - min) / (max - min);
          return [
            Math.round(color1[0] + t * (color2[0] - color1[0])),
            Math.round(color1[1] + t * (color2[1] - color1[1])),
            Math.round(color1[2] + t * (color2[2] - color1[2]))
          ];
        }
        const renderer = {
          type: "unique-value",
          field: "FIPS",
          uniqueValueInfos: Object.entries(countyCounts).map(([fips, count]) => ({
            value: fips,
            symbol: {
              type: "simple-fill",
              color: interpolateColor(count, minCount, maxCount, colorRamp[0], colorRamp[1]),
              outline: { color: "#000000", width: 1 }
            },
            label: `${fips} (${count})`
          })),
          defaultSymbol: {
            type: "simple-fill",
            color: [240, 240, 240, 0.1],
            outline: { color: "#000000", width: 1 }
          },
          defaultLabel: "No data"
        };
        countiesLayer.renderer = renderer;
      }

      const professionalsCsvUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSiG1o19np3JNB_Yk7n3ZjlJE9PalBE1mHZQdK9C6FGK4thWkeLo4WLbT5fvCmMrGxSkRJj1U_tjSWz/pub?gid=1613606573&single=true&output=csv";
      const blueTrianglesCsvUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQmteZYNavJP873NH8cOh7mXEsNrz4Vypaxt5kjMSnOIvcdo2oWJ9Vf9IDJOLh4qqz4zo3b4yzkClsk/pub?gid=113644683&single=true&output=csv";
      const yellowTrianglesCsvUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQmteZYNavJP873NH8cOh7mXEsNrz4Vypaxt5kjMSnOIvcdo2oWJ9Vf9IDJOLh4qqz4zo3b4yzkClsk/pub?gid=515295673&single=true&output=csv";

      async function loadData() {
        let professionalsFeatures = [];
        await Promise.all([
          (async () => { professionalsFeatures = await loadProfessionalsLayer(); })(),
          loadBlueTrianglesLayer(),
          loadYellowTrianglesLayer()
        ]);
        updateCountyShading(professionalsFeatures, countiesLayer);
        // Store for search
        professionalsData = professionalsFeatures;
      }
      
      async function loadYellowTrianglesLayer() {
        console.log("Fetching Yellow Triangles CSV data...");
        try {
          const response = await fetch(yellowTrianglesCsvUrl);
          if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          const csvText = await response.text();
          const jsonData = parseCSV(csvText);
          if (jsonData.length === 0) throw new Error("No data found in CSV");
          const features = parseYellowTriangleFeatures(jsonData);
          const headers = jsonData[0];
          yellowTrianglesData = features;
          await createYellowTrianglesLayer(features, headers);
          console.log("✅ Yellow Triangles CSV data loaded successfully!");
        } catch (error) {
          console.error("❌ Failed to load Yellow Triangles CSV:", error);
          alert(`Failed to load Yellow Triangles data: ${error.message}`);
        }
      }
      async function createYellowTrianglesLayer(features, headers) {
        const fields = [{ name: "ObjectID", type: "oid" }];
        headers.forEach(header => {
          if (header && header.toString().trim()) {
            const fieldName = header.toString().trim();
            let fieldType = "string";
            if (fieldName.toLowerCase().includes("latitude") || 
                fieldName.toLowerCase().includes("longitude") ||
                fieldName.toLowerCase().includes("lat") ||
                fieldName.toLowerCase().includes("long")) {
              fieldType = "double";
            } else if (fieldName.toLowerCase().includes("id") ||
                      fieldName.toLowerCase().includes("number") ||
                      fieldName.toLowerCase().includes("count")) {
              fieldType = "integer";
            }
            fields.push({ name: fieldName, type: fieldType });
          }
        });

        const renderer = {
          type: "simple",
          symbol: {
            type: "simple-marker",
            style: "triangle",
            color: "#FFFF00", 
            size: "14px",
            outline: { color: "#000000", width: 2 }
          }
        };

        const yellowTrianglesLayer = new FeatureLayer({
          source: features,
          title: "Yellow Triangle Points",
          objectIdField: "ObjectID",
          geometryType: "point",
          spatialReference: { wkid: 4326 },
          fields: fields,
          renderer: renderer,
          popupTemplate: {
            title: "Point Info",
            content: createPopupContent(headers)
          },
          visible: false
        });
        yellowTrianglesLayerRef = yellowTrianglesLayer;
        map.add(yellowTrianglesLayer);
      }

      async function loadProfessionalsLayer() {
        console.log("Fetching Professionals CSV data...");
        try {
          const response = await fetch(professionalsCsvUrl);
          if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          const csvText = await response.text();
          const jsonData = parseCSV(csvText);
          if (jsonData.length === 0) throw new Error("No data found in CSV");
          const features = parseExcelToFeatures(jsonData);
          const headers = jsonData[0];
          await createProfessionalsLayer(features, headers);
          console.log("✅ Professionals CSV data loaded successfully!");
           return features;
        } catch (error) {
          console.error("❌ Failed to load Professionals CSV:", error);
          alert(`Failed to load Professionals data: ${error.message}`);
          return [];
        }
      }

      async function loadBlueTrianglesLayer() {
        console.log("Fetching Blue Triangles CSV data...");
        try {
          const response = await fetch(blueTrianglesCsvUrl);
          if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          const csvText = await response.text();
          const jsonData = parseCSV(csvText);
          if (jsonData.length === 0) throw new Error("No data found in CSV");
          const features = parseBlueTriangleFeatures(jsonData);
          const headers = jsonData[0];
          blueTrianglesData = features;
          await createBlueTrianglesLayer(features, headers);
          console.log("✅ Blue Triangles CSV data loaded successfully!");
        } catch (error) {
          console.error("❌ Failed to load Blue Triangles CSV:", error);
          alert(`Failed to load Blue Triangles data: ${error.message}`);
        }
      }
      function parseCSV(text) {
        const rows = [];
        let cur = '', inQuotes = false, row = [];
        for (let i = 0; i < text.length; i++) {
          const c = text[i];
          if (c === '"') {
            if (inQuotes && text[i+1] === '"') { cur += '"'; i++; }
            else inQuotes = !inQuotes;
          } else if (c === ',' && !inQuotes) {
            row.push(cur); cur = '';
          } else if ((c === '\n' || c === '\r') && !inQuotes) {
            if (cur !== '' || row.length > 0) { row.push(cur); rows.push(row); }
            cur = ''; row = [];
            if (c === '\r' && text[i+1] === '\n') i++;
          } else {
            cur += c;
          }
        }
        if (cur !== '' || row.length > 0) { row.push(cur); rows.push(row); }
        return rows.filter(r => r.length && r.some(cell => cell.trim() !== ''));
      }
      
      async function createProfessionalsLayer(features, headers) {
        const fields = [{ name: "ObjectID", type: "oid" }];
        headers.forEach(header => {
          if (header && header.toString().trim()) {
            const fieldName = header.toString().trim();
            let fieldType = "string";
            if (/^lat/i.test(fieldName) || /^lon/i.test(fieldName) || fieldName.toLowerCase().includes("latitude") || fieldName.toLowerCase().includes("longitude")) {
              fieldType = "double";
            } else if (fieldName.toLowerCase().includes("id") ||
                      fieldName.toLowerCase().includes("number") ||
                      fieldName.toLowerCase().includes("count")) {
              fieldType = "integer";
            }
            fields.push({ name: fieldName, type: fieldType });
          }
        });

        const roleColors = {
          "Construction, Installation, and Maintenance": "#FFA910",
          "Engineering & Technical Design or Advisor": "#FFFF01",
          "Field Service and Water Treatment": "#FF0000",
          "Finance and Accounting": "#DBFF78",
          "Leadership and management (non-Sales)": "#80B1D3",
          "Logistics, Delivery, and Warehousing": "#FDB462",
          "Manufacturing and Assembly": "#FFB2D3",
          "Other": "#E1E1E1",
          "Quality": "#4EEAD9",
          "Quality/Sampling/Laboratory": "#BC808D",
          "Sales and Account Management": "#4CE600"
        };

        let roleField = headers.find(h => h && (h.trim() === "Role_Category" || h.trim() === "Role Category"));
        if (!roleField) {
          roleField = headers.find(h => h && h.toString().replace(/[_ ]/g, '').toLowerCase().includes("rolecategory"));
        }
        let renderer;
        if (roleField) {
          renderer = {
            type: "unique-value",
            field: roleField,
            uniqueValueInfos: Object.entries(roleColors).map(([role, color]) => ({
              value: role,
              symbol: {
                type: "simple-marker",
                color: color,
                size: "10px",
                outline: { color: "#000000", width: 2 }
              },
              label: role
            }))
          };
        } else {
          renderer = {
            type: "simple",
            symbol: {
              type: "simple-marker",
              color: "#FF6600",
              size: "10px",
              outline: { color: "#000000", width: 2 }
            }
          };
        }

        console.log(`Professionals features created: ${features.length}`);
        if (features.length === 0) {
          console.warn("No features created for professionals layer. Check latitude/longitude column names and data.");
        }

        const professionalsLayer = new FeatureLayer({
          source: features,
          title: "Water Treatment Professionals",
          objectIdField: "ObjectID",
          geometryType: "point",
          spatialReference: { wkid: 4326 },
          fields: fields,
          renderer: renderer,
          popupTemplate: {
            title: "Water Treatment Professional",
            content: createPopupContent(headers)
          },
          visible: true
        });
        map.add(professionalsLayer);
        professionalsLayerRef = professionalsLayer;
        if (features.length > 0) {
          professionalsLayer.when(() => {
            return professionalsLayer.queryExtent();
          }).then((response) => {
            view.goTo(response.extent.expand(1.2));
          });
        }
      }

      async function createBlueTrianglesLayer(features, headers) {
        const fields = [{ name: "ObjectID", type: "oid" }];
        headers.forEach(header => {
          if (header && header.toString().trim()) {
            const fieldName = header.toString().trim();
            let fieldType = "string";
            if (fieldName.toLowerCase().includes("latitude") || 
                fieldName.toLowerCase().includes("longitude") ||
                fieldName.toLowerCase().includes("lat") ||
                fieldName.toLowerCase().includes("long")) {
              fieldType = "double";
            } else if (fieldName.toLowerCase().includes("id") ||
                      fieldName.toLowerCase().includes("number") ||
                      fieldName.toLowerCase().includes("count")) {
              fieldType = "integer";
            }
            fields.push({ name: fieldName, type: fieldType });
          }
        });

        const renderer = {
          type: "simple",
          symbol: {
            type: "simple-marker",
            style: "triangle",
            color: "#0074D9", 
            size: "14px",
            outline: { color: "#003366", width: 2 }
          }
        };

        const blueTrianglesLayer = new FeatureLayer({
          source: features,
          title: "Blue Triangle Points",
          objectIdField: "ObjectID",
          geometryType: "point",
          spatialReference: { wkid: 4326 },
          fields: fields,
          renderer: renderer,
          popupTemplate: {
            title: "Point Info",
            content: createPopupContent(headers)
          },
          visible: false
        });
        blueTrianglesLayerRef = blueTrianglesLayer;
        map.add(blueTrianglesLayer);
      }
      
      function parseExcelToFeatures(jsonData) {
        if (jsonData.length < 2) return [];
        const headers = jsonData[0].map(h => h ? h.toString().trim() : '');
        const features = [];
        const latIndex = findColumnIndex(headers, ['latitude', 'lat', 'zip_latitude', 'Lat']);
        const lonIndex = findColumnIndex(headers, ['longitude', 'lon', 'lng', 'zip_longitude', 'Long']);
        const fipsIndex = findColumnIndex(headers, ['5_digit_FIPS_Code', 'FIPS', 'FIPS_Code', 'fips']);
        console.log("Headers found:", headers);
        console.log(`Latitude column: ${headers[latIndex]} (index: ${latIndex})`);
        console.log(`Longitude column: ${headers[lonIndex]} (index: ${lonIndex})`);
        if (latIndex === -1 || lonIndex === -1) {
          throw new Error("Could not find latitude/longitude columns");
        }
        for (let i = 1; i < jsonData.length; i++) {
          const row = jsonData[i];
          const attributes = { ObjectID: i };
          headers.forEach((header, index) => {
            if (header) {
              attributes[header] = row[index] || '';
            }
          });
          if (fipsIndex !== -1) {
            attributes['FIPS'] = row[fipsIndex] || '';
          }
          const lat = parseFloat(row[latIndex]);
          const lon = parseFloat(row[lonIndex]);
          if (!isNaN(lat) && !isNaN(lon) && lat !== 0 && lon !== 0) {
            features.push({
              geometry: {
                type: "point",
                longitude: lon,
                latitude: lat
              },
              attributes: attributes
            });
          }
        }
        return features;
      }
      function parseBlueTriangleFeatures(jsonData) {
        if (jsonData.length < 2) return [];
        const headers = jsonData[0].map(h => h ? h.toString().trim() : '');
        const features = [];
        const latIndex = findColumnIndex(headers, ['lat']);
        const lonIndex = findColumnIndex(headers, ['long']);
        console.log("Headers found (blue triangles):", headers);
        console.log(`Latitude column: ${headers[latIndex]} (index: ${latIndex})`);
        console.log(`Longitude column: ${headers[lonIndex]} (index: ${lonIndex})`);
        if (latIndex === -1 || lonIndex === -1) {
          throw new Error("Could not find Lat/Long columns");
        }
        for (let i = 1; i < jsonData.length; i++) {
          const row = jsonData[i];
          const attributes = { ObjectID: i };
          headers.forEach((header, index) => {
            if (header) {
              attributes[header] = row[index] || '';
            }
          });
          const lat = parseFloat(row[latIndex]);
          const lon = parseFloat(row[lonIndex]);
          if (!isNaN(lat) && !isNaN(lon) && lat !== 0 && lon !== 0) {
            features.push({
              geometry: {
                type: "point",
                longitude: lon,
                latitude: lat
              },
              attributes: attributes
            });
          }
        }
        return features;
      }
      function parseYellowTriangleFeatures(jsonData) {
        if (jsonData.length < 2) return [];
        const headers = jsonData[0].map(h => h ? h.toString().trim() : '');
        const features = [];
        const latIndex = findColumnIndex(headers, ['latitude', 'lat']);
        const lonIndex = findColumnIndex(headers, ['longitude', 'lon', 'lng']);
        console.log("Headers found (yellow triangles):", headers);
        console.log(`Latitude column: ${headers[latIndex]} (index: ${latIndex})`);
        console.log(`Longitude column: ${headers[lonIndex]} (index: ${lonIndex})`);
        if (latIndex === -1 || lonIndex === -1) {
          throw new Error("Could not find Latitude/Longitude columns");
        }
        for (let i = 1; i < jsonData.length; i++) {
          const row = jsonData[i];
          const attributes = { ObjectID: i };
          headers.forEach((header, index) => {
            if (header) {
              attributes[header] = row[index] || '';
            }
          });
          const lat = parseFloat(row[latIndex]);
          const lon = parseFloat(row[lonIndex]);
          if (!isNaN(lat) && !isNaN(lon) && lat !== 0 && lon !== 0) {
            features.push({
              geometry: {
                type: "point",
                longitude: lon,
                latitude: lat
              },
              attributes: attributes
            });
          }
        }
        return features;
      }
      
      function findColumnIndex(headers, possibleNames) {
        for (const name of possibleNames) {
          const index = headers.findIndex(h => 
            h && h.toLowerCase().includes(name.toLowerCase())
          );
          if (index !== -1) return index;
        }
        return -1;
      }
      
      function createPopupContent(headers) {
        let content = "";
        headers.forEach(header => {
          if (header && header.toString().trim()) {
            const fieldName = header.toString().trim();
            content += `<b>${fieldName}:</b> {${fieldName}}<br>`;
          }
        });
        return content;
      }
      
      const searchBoxInput = document.getElementById("searchBox");
      const searchSuggestions = document.getElementById("searchSuggestions");


      function getKeyFields(layerType) {
        if (layerType === 'professionals') {
          return [
            'First_name', 'Last_name', 'Company', 'City', 'State', 'Role_Category', 'Role Category', 'Professional_Index', 'Email', 'Title'
          ];
        } else if (layerType === 'blue') {
          return [
            'Company', 'City', 'State', 'Contact', 'Name', 'AWT_Member', 'AWT Member', 'Email', 'Title'
          ];
        } else if (layerType === 'yellow') {
          return [
            'Company', 'City', 'State', 'Contact', 'Name', 'Email', 'Title'
          ];
        }
        return [];
      }

      function featureToSearchString(feature, layerType) {
        const attrs = feature.attributes || {};
        const keyFields = getKeyFields(layerType);
        return keyFields.map(f => (attrs[f] || '').toString().toLowerCase()).join(' ');
      }
      function featureLabel(feature, maxFields = 3) {
        const attrs = feature.attributes || {};
        let keys = [];
        if (attrs['First_name'] && attrs['Last_name']) {
          keys = ['Professional_Index', 'First_name', 'Last_name'];
        } else if (attrs['Company'] && attrs['City']) {
          keys = ['Company', 'City', 'State'];
        } else {
          keys = Object.keys(attrs).filter(k => attrs[k] && typeof attrs[k] === 'string');
        }
        return keys.slice(0, maxFields).map(k => `<b>${k}:</b> ${attrs[k]}`).join(' | ');
      }

      searchBoxInput.addEventListener("input", function(e) {
        const q = searchBoxInput.value.trim().toLowerCase();
        if (!q) {
          searchSuggestions.style.display = "none";
          searchSuggestions.innerHTML = "";
          return;
        }
        const words = q.split(/\s+/).filter(Boolean);
        const maxPerLayer = 8;
        function matchesAllWords(feature, layerType) {
          const searchStr = featureToSearchString(feature, layerType);
          return words.every(word => searchStr.includes(word));
        }
        const proMatches = professionalsData.filter(f => matchesAllWords(f, 'professionals')).slice(0, maxPerLayer);
        const blueMatches = blueTrianglesData.filter(f => matchesAllWords(f, 'blue')).slice(0, maxPerLayer);
        const yellowMatches = yellowTrianglesData.filter(f => matchesAllWords(f, 'yellow')).slice(0, maxPerLayer);
        let html = "";
        if (proMatches.length) {
          html += `<div style='padding:4px 8px; font-weight:bold; color:#034d46; background:#e6f2ef;'>Water Treatment Professionals</div>`;
          proMatches.forEach(f => {
            html += `<div class='search-suggestion' data-layer='professionals' data-oid='${f.attributes.ObjectID}' style='padding:4px 8px; cursor:pointer;'>${featureLabel(f)}</div>`;
          });
        }
        if (blueMatches.length) {
          html += `<div style='padding:4px 8px; font-weight:bold; color:#003366; background:#e6eaff;'>AWT + Water treaters</div>`;
          blueMatches.forEach(f => {
            html += `<div class='search-suggestion' data-layer='blue' data-oid='${f.attributes.ObjectID}' style='padding:4px 8px; cursor:pointer;'>${featureLabel(f)}</div>`;
          });
        }
        if (yellowMatches.length) {
          html += `<div style='padding:4px 8px; font-weight:bold; color:#bfa800; background:#fffbe6;'>Companies for linked-in search</div>`;
          yellowMatches.forEach(f => {
            html += `<div class='search-suggestion' data-layer='yellow' data-oid='${f.attributes.ObjectID}' style='padding:4px 8px; cursor:pointer;'>${featureLabel(f)}</div>`;
          });
        }
        if (!html) html = `<div style='padding:8px; color:#888;'>No matches found</div>`;
        searchSuggestions.innerHTML = html;
        searchSuggestions.style.display = "block";
      });
      document.addEventListener("click", function(e) {
        if (!searchSuggestions.contains(e.target) && e.target !== searchBoxInput) {
          searchSuggestions.style.display = "none";
        }
      });
      let highlightHandle = null;
      searchSuggestions.addEventListener("click", async function(e) {
        const el = e.target.closest('.search-suggestion');
        if (!el) return;
        const layerType = el.getAttribute('data-layer');
        const oid = parseInt(el.getAttribute('data-oid'));
        let layerRef = null, dataArr = null;
        if (layerType === 'professionals') {
          layerRef = professionalsLayerRef;
          dataArr = professionalsData;
        } else if (layerType === 'blue') {
          layerRef = blueTrianglesLayerRef;
          dataArr = blueTrianglesData;
        } else if (layerType === 'yellow') {
          layerRef = yellowTrianglesLayerRef;
          dataArr = yellowTrianglesData;
        }
        if (!layerRef || !dataArr) return;
        const feature = dataArr.find(f => f.attributes.ObjectID == oid);
        if (!feature) return;
        if (feature.geometry && feature.geometry.longitude !== undefined && feature.geometry.latitude !== undefined) {
          view.goTo({
            center: [feature.geometry.longitude, feature.geometry.latitude],
            zoom: 12
          });
        }
        try {
          const layerView = await view.whenLayerView(layerRef);
          if (highlightHandle) highlightHandle.remove();
          highlightHandle = layerView.highlight([{ ObjectID: oid }]);
          setTimeout(() => {
            if (highlightHandle) highlightHandle.remove();
            highlightHandle = null;
          }, 2500);
        } catch (err) {
        }
        searchSuggestions.style.display = "none";
      });

      loadData();

    const layersBtn = document.getElementById("layersBtn");
    const layersDropdown = document.getElementById("layersDropdown");
    layersBtn.addEventListener("click", function(e) {
      e.stopPropagation();
      layersDropdown.style.display = layersDropdown.style.display === "block" ? "none" : "block";
    });
    document.addEventListener("click", function(e) {
      if (!layersDropdown.contains(e.target) && e.target !== layersBtn) {
        layersDropdown.style.display = "none";
      }
    });

    document.getElementById("chkProfessionals").addEventListener("change", function(e) {
      if (professionalsLayerRef) professionalsLayerRef.visible = e.target.checked;
    });
    document.getElementById("chkCounties").addEventListener("change", function(e) {
      if (countiesLayerRef) countiesLayerRef.visible = e.target.checked;
    });
    document.getElementById("chkBlueTriangles").addEventListener("change", function(e) {
      if (blueTrianglesLayerRef) blueTrianglesLayerRef.visible = e.target.checked;
    });
    document.getElementById("chkYellowTriangles").addEventListener("change", function(e) {
      if (yellowTrianglesLayerRef) yellowTrianglesLayerRef.visible = e.target.checked;
    });

    const manipulatorPane = document.getElementById("manipulatorPane");
    const manipulatorCloseBtn = document.getElementById("manipulatorCloseBtn");
    manipulatorCloseBtn.addEventListener("click", function() {
      manipulatorPane.style.display = 'none';
    });
    const legendBtn = document.getElementById("legendBtn");
    const legendContent = document.getElementById("legendContent");

    let filterState = {
      roleCategories: new Set(),
      parentCompanies: new Set(),
      enabledRoles: new Set(),
      enabledCompanies: new Set()
    };

    function getProfessionalsUniqueValues(field) {
      if (!professionalsData.length) return [];
      const values = new Set();
      professionalsData.forEach(f => {
        const v = f.attributes[field];
        if (v && v.toString().trim()) values.add(v.toString().trim());
      });
      return Array.from(values).sort();
    }

    const filterBtn = document.getElementById("filterBtn");
    filterBtn.addEventListener("click", function() {
      manipulatorPane.style.display = 'flex';
      renderFilterUI();
    });

    function renderFilterUI() {
      const roleField = professionalsData.length && (professionalsData[0].attributes["Role_Category"] !== undefined ? "Role_Category" : (professionalsData[0].attributes["Role Category"] !== undefined ? "Role Category" : null));
      const companyField = professionalsData.length && (professionalsData[0].attributes["Updated_Parent_Company"] !== undefined ? "Updated_Parent_Company" : null);
      const roles = roleField ? getProfessionalsUniqueValues(roleField) : [];
      const companies = companyField ? getProfessionalsUniqueValues(companyField) : [];
      if (!filterState.enabledRoles.size) roles.forEach(r => filterState.enabledRoles.add(r));
      if (!filterState.enabledCompanies.size) companies.forEach(c => filterState.enabledCompanies.add(c));
      let html = `<div style='font-weight:bold; font-size:17px; margin-bottom:10px; color:#1a3a5b;'>Filter Professionals</div>`;
      if (roles.length) {
        html += `<div style='margin-bottom:10px;'><span style='font-weight:bold;'>Role Category</span><br>`;
        roles.forEach(role => {
          const checked = filterState.enabledRoles.has(role) ? 'checked' : '';
          html += `<label style='display:block; margin:2px 0;'><input type='checkbox' class='filter-role' value="${role.replace(/"/g,'&quot;')}" ${checked}> ${role}</label>`;
        });
        html += `</div>`;
      }
      if (companies.length) {
        html += `<div style='margin-bottom:10px;'><span style='font-weight:bold;'>Updated Parent Company</span><br>`;
        companies.forEach(company => {
          const checked = filterState.enabledCompanies.has(company) ? 'checked' : '';
          html += `<label style='display:block; margin:2px 0;'><input type='checkbox' class='filter-company' value="${company.replace(/"/g,'&quot;')}" ${checked}> ${company}</label>`;
        });
        html += `</div>`;
      }
      if (!roles.length && !companies.length) {
        html += `<div style='color:#888;'>No filterable fields found in professionals layer.</div>`;
      }
      html += `<div style='margin-top:12px; display:flex; gap:10px;'>
        <button id='checkAllFiltersBtn' style='padding:6px 18px; background:#034d46; color:#fff; border:none; border-radius:4px; font-weight:bold; cursor:pointer;'>Check All</button>
        <button id='clearAllFiltersBtn' style='padding:6px 18px; background:#b80000; color:#fff; border:none; border-radius:4px; font-weight:bold; cursor:pointer;'>Clear All</button>
      </div>`;
      legendContent.innerHTML = html;
      document.querySelectorAll('.filter-role').forEach(cb => {
        cb.addEventListener('change', function(e) {
          if (e.target.checked) filterState.enabledRoles.add(e.target.value);
          else filterState.enabledRoles.delete(e.target.value);
          applyProfessionalsFilter();
        });
      });
      document.querySelectorAll('.filter-company').forEach(cb => {
        cb.addEventListener('change', function(e) {
          if (e.target.checked) filterState.enabledCompanies.add(e.target.value);
          else filterState.enabledCompanies.delete(e.target.value);
          applyProfessionalsFilter();
        });
      });
      const checkAllBtn = document.getElementById('checkAllFiltersBtn');
      if (checkAllBtn) {
        checkAllBtn.addEventListener('click', function() {
          document.querySelectorAll('.filter-role').forEach(cb => {
            cb.checked = true;
            filterState.enabledRoles.add(cb.value);
          });
          document.querySelectorAll('.filter-company').forEach(cb => {
            cb.checked = true;
            filterState.enabledCompanies.add(cb.value);
          });
          applyProfessionalsFilter();
        });
      }
      const clearAllBtn = document.getElementById('clearAllFiltersBtn');
      if (clearAllBtn) {
        clearAllBtn.addEventListener('click', function() {
          document.querySelectorAll('.filter-role').forEach(cb => {
            cb.checked = false;
            filterState.enabledRoles.delete(cb.value);
          });
          document.querySelectorAll('.filter-company').forEach(cb => {
            cb.checked = false;
            filterState.enabledCompanies.delete(cb.value);
          });
          applyProfessionalsFilter();
        });
      }
    }

    function applyProfessionalsFilter() {
      if (!professionalsLayerRef) return;
      const roleField = professionalsData.length && (professionalsData[0].attributes["Role_Category"] !== undefined ? "Role_Category" : (professionalsData[0].attributes["Role Category"] !== undefined ? "Role Category" : null));
      const companyField = professionalsData.length && (professionalsData[0].attributes["Updated_Parent_Company"] !== undefined ? "Updated_Parent_Company" : null);
      let clauses = [];
      if (roleField) {
        if (filterState.enabledRoles.size === 0) {
          clauses.push('1=0'); 
        } else if (filterState.enabledRoles.size !== getProfessionalsUniqueValues(roleField).length) {
          const vals = Array.from(filterState.enabledRoles).map(v => `'${v.replace(/'/g, "''")}'`).join(",");
          clauses.push(`${roleField} IN (${vals})`);
        }
      }
      if (companyField) {
        if (filterState.enabledCompanies.size === 0) {
          clauses.push('1=0'); 
        } else if (filterState.enabledCompanies.size !== getProfessionalsUniqueValues(companyField).length) {
          const vals = Array.from(filterState.enabledCompanies).map(v => `'${v.replace(/'/g, "''")}'`).join(",");
          clauses.push(`${companyField} IN (${vals})`);
        }
      }
      if (clauses.length) {
        professionalsLayerRef.definitionExpression = clauses.join(' AND ');
      } else {
        professionalsLayerRef.definitionExpression = null;
      }
      if (typeof updateMapCounter === 'function') {
        updateMapCounter();
      }
    }

    const toolboxDiv = document.getElementById('toolbox');
    if (toolboxDiv) {
      toolboxDiv.style.display = 'flex';
      toolboxDiv.style.flexDirection = 'row';
      toolboxDiv.style.alignItems = 'center';
      toolboxDiv.style.justifyContent = 'flex-start';
      toolboxDiv.style.gap = '0';
    }
    let leftControls = document.getElementById('toolbox-left-controls');
    if (!leftControls) {
      leftControls = document.createElement('div');
      leftControls.id = 'toolbox-left-controls';
      leftControls.style.display = 'flex';
      leftControls.style.flexDirection = 'row';
      leftControls.style.alignItems = 'center';
      leftControls.style.flexGrow = '1';
      leftControls.style.gap = '16px';
      while (toolboxDiv.firstChild) {
        leftControls.appendChild(toolboxDiv.firstChild);
      }
      toolboxDiv.appendChild(leftControls);
    }

    const csvExportBtn = document.createElement('button');
    csvExportBtn.id = 'csvExportBtn';
    csvExportBtn.textContent = 'CSV Export';
    csvExportBtn.style.padding = '6px 14px';
    csvExportBtn.style.background = '#fff';
    csvExportBtn.style.color = '#034d46';
    csvExportBtn.style.borderRadius = '4px';
    csvExportBtn.style.border = 'none';
    csvExportBtn.style.fontWeight = 'bold';
    csvExportBtn.style.cursor = 'pointer';
    csvExportBtn.style.marginLeft = '16px';
    csvExportBtn.style.marginRight = '0px';
    if (searchBoxInput && searchBoxInput.parentNode === leftControls) {
      if (searchBoxInput.nextSibling) {
        leftControls.insertBefore(csvExportBtn, searchBoxInput.nextSibling);
      } else {
        leftControls.appendChild(csvExportBtn);
      }
    } else {
      leftControls.appendChild(csvExportBtn);
    }

    csvExportBtn.addEventListener('click', function() {

      function matchesDefinitionExpression(feature, layerRef) {
        if (!layerRef || !layerRef.definitionExpression) return true;
        const expr = layerRef.definitionExpression;
        const clauses = expr.split(/\s+AND\s+/i);
        for (const clause of clauses) {
          const match = clause.match(/^(\w+) IN \(([^)]+)\)$/);
          if (match) {
            const field = match[1];
            const allowed = match[2].split(/,(?=(?:[^']*'[^']*')*[^']*$)/).map(s => s.trim().replace(/^'/, '').replace(/'$/, '').replace(/''/g, "'"));
            const val = feature.attributes[field] || '';
            if (!allowed.includes(val)) return false;
          } else if (clause.trim() === '1=0') {
            return false;
          }
        }
        return true;
      }


      let selected = window._lastSelectedFeatures || {
        professionals: [],
        blue: [],
        yellow: []
      };
      if (typeof selectHighlightHandle === 'object' && selectHighlightHandle.selectedFeatures) {
        selected = selectHighlightHandle.selectedFeatures;
      }


      let filteredProfessionals = [];
      if (selected.professionals && selected.professionals.length) {
        filteredProfessionals = selected.professionals.filter(f => matchesDefinitionExpression(f, professionalsLayerRef));
      }

      if (
        (!filteredProfessionals.length) &&
        (!selected.blue || !selected.blue.length) &&
        (!selected.yellow || !selected.yellow.length)
      ) {
        alert('No features are selected. Use the Select tool to select points first.');
        return;
      }

      function featuresToCSV(features) {
        if (!features.length) return '';
        const headers = Object.keys(features[0].attributes);
        const escape = v => '"' + (v == null ? '' : (''+v).replace(/"/g,'""')) + '"';
        const rows = [headers.map(escape).join(',')];
        features.forEach(f => {
          rows.push(headers.map(h => escape(f.attributes[h])).join(','));
        });
        return rows.join('\r\n');
      }

      let html = `<!DOCTYPE html><html><head><title>CSV Export</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 0; padding: 0; }
          .tabs { display: flex; border-bottom: 1px solid #ccc; }
          .tab { padding: 10px 24px; cursor: pointer; border: none; background: #f5f5f5; font-weight: bold; }
          .tab.active { background: #fff; border-bottom: 2px solid #034d46; color: #034d46; }
          .csv-content { display: none; padding: 18px; font-size: 15px; }
          .csv-content.active { display: block; }
          textarea { width: 100%; height: 400px; font-family: monospace; font-size: 14px; }
        </style>
      </head><body>`;
      html += `<div class='tabs'>`;
      const tabOrder = [];
      if (filteredProfessionals.length) {
        html += `<button class='tab active'>Professionals (${filteredProfessionals.length})</button>`;
        tabOrder.push('professionals');
      }
      if (selected.blue && selected.blue.length) {
        html += `<button class='tab${tabOrder.length ? '' : ' active'}'>AWT + Water Treaters (${selected.blue.length})</button>`;
        tabOrder.push('blue');
      }
      if (selected.yellow && selected.yellow.length) {
        html += `<button class='tab${tabOrder.length ? '' : ' active'}'>Companies for Linked-in (${selected.yellow.length})</button>`;
        tabOrder.push('yellow');
      }
      html += `</div>`;
      tabOrder.forEach((key, i) => {
        let features = [];
        if (key === 'professionals') {
          features = filteredProfessionals;
        } else {
          features = selected[key];
        }
        html += `<div class='csv-content${i === 0 ? ' active' : ''}' id='csvTab${i}'>`;
        html += `<textarea readonly>${featuresToCSV(features)}</textarea>`;
        html += `<br><button class='download-csv-btn' data-idx='${i}' style="margin-top:8px; padding:6px 18px; background:#034d46; color:#fff; border:none; border-radius:4px; font-weight:bold; cursor:pointer;">Download CSV</button>`;
        html += `</div>`;
      });
      html += `<script>(function(){
        var tabs = document.querySelectorAll('.tab');
        var contents = document.querySelectorAll('.csv-content');
        tabs.forEach(function(tab, idx) {
          tab.addEventListener('click', function() {
            tabs.forEach(function(t, i) { t.classList.remove('active'); contents[i].classList.remove('active'); });
            tab.classList.add('active');
            contents[idx].classList.add('active');
          });
        });
        var downloadBtns = document.querySelectorAll('.download-csv-btn');
        downloadBtns.forEach(function(btn, idx) {
          btn.addEventListener('click', function() {
            var text = contents[idx].querySelector('textarea').value;
            var blob = new Blob([text], {type:'text/csv'});
            var url = URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            a.download = tabs[idx].textContent.replace(/\s*\(.*\)/, '') + '.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            setTimeout(function(){ URL.revokeObjectURL(url); }, 1000);
          });
        });
      })();<\/script><\/body><\/html>`;
      const win = window.open('', '_blank');
      win.document.write(html);
      win.document.close();
    });
    const counterDiv = document.createElement('div');
    counterDiv.id = 'mapCounterOverlay';
    counterDiv.style.display = 'block';
    counterDiv.style.color = '#034d46';
    counterDiv.style.fontWeight = 'bold';
    counterDiv.style.fontSize = '15px';
    counterDiv.style.textAlign = 'right';
    counterDiv.style.marginLeft = '24px';
    counterDiv.style.padding = '0 12px';
    counterDiv.style.background = 'none';
    counterDiv.style.border = 'none';
    counterDiv.style.boxShadow = 'none';
    counterDiv.style.pointerEvents = 'none';
    counterDiv.style.minWidth = '260px';
    counterDiv.style.flexShrink = '0';
    toolboxDiv.appendChild(counterDiv);

    async function updateMapCounter() {
      if (!view) return;
      const extent = view.extent;
      async function countFeatures(layerRef) {
        if (!layerRef || !layerRef.visible) return 0;
        try {
          const where = layerRef.definitionExpression && layerRef.definitionExpression.trim() ? layerRef.definitionExpression : '1=1';
          const result = await layerRef.queryFeatureCount({
            geometry: extent,
            spatialRelationship: 'intersects',
            where: where
          });
          return result;
        } catch (e) {
          return 0;
        }
      }
      const [proCount, blueCount, yellowCount] = await Promise.all([
        countFeatures(professionalsLayerRef),
        countFeatures(blueTrianglesLayerRef),
        countFeatures(yellowTrianglesLayerRef)
      ]);
      const total = proCount + blueCount + yellowCount;
      let html = '';
      html += `<span style='color:#f5f2e6;'>Professionals:</span> <b style='color:#fff;'>${proCount}</b> &nbsp;`;
      html += `<span style='color:#0074D9;'>AWT + Water Treaters:</span> <b style='color:#fff;'>${blueCount}</b> &nbsp;`;
      html += `<span style='color:#bfa800;'>Companies for Linked-in:</span> <b style='color:#fff;'>${yellowCount}</b> &nbsp;`;
      html += `<span style='color:#888;'>Total:</span> <b style='color:#fff;'>${total}</b>`;
      counterDiv.innerHTML = html;
    }

    function setupCounterEvents() {
      if (!view) return;
      require(["esri/core/reactiveUtils"], function(reactiveUtils) {
        reactiveUtils.watch(
          () => view.extent,
          () => updateMapCounter()
        );
      });
      [
        document.getElementById('chkProfessionals'),
        document.getElementById('chkBlueTriangles'),
        document.getElementById('chkYellowTriangles')
      ].forEach(cb => {
        if (cb) cb.addEventListener('change', updateMapCounter);
      });
      setTimeout(updateMapCounter, 1200);
    }

    if (window.requestAnimationFrame) {
      window.requestAnimationFrame(setupCounterEvents);
    } else {
      setTimeout(setupCounterEvents, 500);
    }

    const selectBtn = document.getElementById("selectBtn");
    const selectDropdown = document.getElementById("selectDropdown");
    let selectMode = null;
    let selectGraphicsLayer = null;
    let selectDragHandler = null;
    let selectLassoPoints = [];
    let selectHighlightHandle = null;

    function deactivateSelectTool() {
      if (selectGraphicsLayer && view) {
        view.map.remove(selectGraphicsLayer);
        selectGraphicsLayer = null;
      }
      if (selectDragHandler) {
        selectDragHandler.remove();
        selectDragHandler = null;
      }
      if (selectHighlightHandle) {
        selectHighlightHandle.remove();
        selectHighlightHandle = null;
      }
      selectLassoPoints = [];
      selectMode = null;
    }

    document.getElementById("viewDiv").addEventListener("contextmenu", function(e) {
      e.preventDefault();
      deactivateSelectTool();
    });

    selectBtn.addEventListener("click", function(e) {
      e.stopPropagation();
      selectDropdown.style.display = selectDropdown.style.display === "block" ? "none" : "block";
    });
    document.addEventListener("click", function(e) {
      if (!selectDropdown.contains(e.target) && e.target !== selectBtn) {
        selectDropdown.style.display = "none";
      }
    });

    selectDropdown.querySelectorAll('.select-option').forEach(opt => {
      opt.addEventListener('click', function(e) {
        selectMode = this.getAttribute('data-mode');
        selectDropdown.style.display = 'none';
        activateSelectMode(selectMode);
      });
    });

function activateSelectMode(mode) {
  if (!view) return;
  if (selectGraphicsLayer) {
    view.map.remove(selectGraphicsLayer);
    selectGraphicsLayer = null;
  }
  if (selectDragHandler) {
    selectDragHandler.remove();
    selectDragHandler = null;
  }
  if (selectHighlightHandle) {
      selectHighlightHandle.remove();
    selectHighlightHandle = null;
  }
  selectLassoPoints = [];
  require(["esri/layers/GraphicsLayer", "esri/Graphic"], function(GraphicsLayer, Graphic) {
    selectGraphicsLayer = new GraphicsLayer();
    view.map.add(selectGraphicsLayer);
    if (mode === 'square') {
      let startPoint = null;
      let rectGraphic = null;
      selectDragHandler = view.on("drag", function(event) {
        event.stopPropagation();
        if (event.action === "start") {
          startPoint = view.toMap({ x: event.x, y: event.y });
          if (rectGraphic) selectGraphicsLayer.remove(rectGraphic);
          rectGraphic = null;
        } else if (event.action === "update" && startPoint) {
          const currPoint = view.toMap({ x: event.x, y: event.y });
          const xmin = Math.min(startPoint.longitude, currPoint.longitude);
          const xmax = Math.max(startPoint.longitude, currPoint.longitude);
          const ymin = Math.min(startPoint.latitude, currPoint.latitude);
          const ymax = Math.max(startPoint.latitude, currPoint.latitude);
          const polygon = {
            type: "polygon",
            rings: [
              [xmin, ymin], [xmax, ymin], [xmax, ymax], [xmin, ymax], [xmin, ymin]
            ],
            spatialReference: { wkid: 4326 }
          };
          if (rectGraphic) selectGraphicsLayer.remove(rectGraphic);
          rectGraphic = new Graphic({
            geometry: polygon,
            symbol: { type: "simple-fill", color: [0, 120, 255, 0.1], outline: { color: [0,120,255,1], width: 2 } }
          });
          selectGraphicsLayer.add(rectGraphic);
        } else if (event.action === "end" && startPoint && rectGraphic) {
          selectFeaturesInGeometry(rectGraphic.geometry);
          startPoint = null;
        }
      });
    } else if (mode === 'lasso') {
      let lassoGraphic = null;
      selectDragHandler = view.on("drag", function(event) {
        event.stopPropagation();
        if (event.action === "start") {
          selectLassoPoints = [view.toMap({ x: event.x, y: event.y })];
          if (lassoGraphic) selectGraphicsLayer.remove(lassoGraphic);
          lassoGraphic = null;
        } else if (event.action === "update") {
          selectLassoPoints.push(view.toMap({ x: event.x, y: event.y }));
          if (lassoGraphic) selectGraphicsLayer.remove(lassoGraphic);
          const rings = selectLassoPoints.map(pt => [pt.longitude, pt.latitude]);
          if (rings.length > 2) rings.push(rings[0]);
          const polygon = {
            type: "polygon",
            rings: rings,
            spatialReference: { wkid: 4326 }
          };
          lassoGraphic = new Graphic({
            geometry: polygon,
            symbol: { type: "simple-fill", color: [0, 120, 255, 0.1], outline: { color: [0,120,255,1], width: 2 } }
          });
          selectGraphicsLayer.add(lassoGraphic);
        } else if (event.action === "end" && selectLassoPoints.length > 2) {
          const rings = selectLassoPoints.map(pt => [pt.longitude, pt.latitude]);
          rings.push(rings[0]);
          const polygon = {
            type: "polygon",
            rings: rings,
            spatialReference: { wkid: 4326 }
          };
          if (lassoGraphic) selectGraphicsLayer.remove(lassoGraphic);
          lassoGraphic = new Graphic({
            geometry: polygon,
            symbol: { type: "simple-fill", color: [0, 120, 255, 0.1], outline: { color: [0,120,255,1], width: 2 } }
          });
          selectGraphicsLayer.add(lassoGraphic);
          selectFeaturesInGeometry(polygon);
          selectLassoPoints = [];
        }
      });
    }
  });
}

    async function selectFeaturesInGeometry(geometry) {
      const layers = [
        { ref: professionalsLayerRef, data: professionalsData, key: 'professionals' },
        { ref: blueTrianglesLayerRef, data: blueTrianglesData, key: 'blue' },
        { ref: yellowTrianglesLayerRef, data: yellowTrianglesData, key: 'yellow' }
      ];
      if (selectHighlightHandle) selectHighlightHandle.remove();
      let highlightHandles = [];
      let selectedFeatures = { professionals: [], blue: [], yellow: [] };
      for (const layer of layers) {
        if (!layer.ref) continue;
        try {
          let query = {
            geometry: geometry,
            spatialRelationship: "intersects",
            returnGeometry: false,
            outFields: ["*"]
          };
          if (layer.key === 'professionals' && layer.ref.definitionExpression) {
            query.where = layer.ref.definitionExpression;
          }
          const result = await layer.ref.queryFeatures(query);
          if (result.features.length) {
            const layerView = await view.whenLayerView(layer.ref);
            const oids = result.features.map(f => f.attributes.ObjectID);
            highlightHandles.push(layerView.highlight(oids));
            if (Array.isArray(layer.data)) {
              selectedFeatures[layer.key] = layer.data.filter(f => oids.includes(f.attributes.ObjectID));
            }
          }
        } catch (e) {
        }
      }
      if (highlightHandles.length) {
        selectHighlightHandle = {
          remove: () => highlightHandles.forEach(h => h && h.remove()),
          selectedFeatures: selectedFeatures
        };
        window._lastSelectedFeatures = selectedFeatures;
      } else {
        selectHighlightHandle = null;
        window._lastSelectedFeatures = { professionals: [], blue: [], yellow: [] };
      }
    }

    function resetFilterState() {
      filterState = {
        roleCategories: new Set(),
        parentCompanies: new Set(),
        enabledRoles: new Set(),
        enabledCompanies: new Set()
      };
    }
    function updateLegend() {
      let html = '<div style="font-weight:bold; font-size:17px; margin-bottom:10px; color:#1a3a5b;">Legend</div>';
      if (professionalsLayerRef && professionalsLayerRef.visible) {
        html += '<div style="margin-bottom:8px;"><span style="font-weight:bold; color:#034d46;">Water Treatment Professionals</span><br>';
        const roleColors = {
          "Construction, Installation, and Maintenance": "#FFA910",
          "Engineering & Technical Design or Advisor": "#FFFF01",
          "Field Service and Water Treatment": "#FF0000",
          "Finance and Accounting": "#DBFF78",
          "Leadership and management (non-Sales)": "#80B1D3",
          "Logistics, Delivery, and Warehousing": "#FDB462",
          "Manufacturing and Assembly": "#FFB2D3",
          "Other": "#E1E1E1",
          "Quality": "#4EEAD9",
          "Quality/Sampling/Laboratory": "#BC808D",
          "Sales and Account Management": "#4CE600"
        };
        Object.entries(roleColors).forEach(([role, color]) => {
          html += `<span style='display:inline-block; width:16px; height:16px; background:${color}; border:2px solid #000; border-radius:50%; margin-right:6px; vertical-align:middle;'></span> <span style='vertical-align:middle;'>${role}</span><br>`;
        });
        html += '</div>';
      }
      if (blueTrianglesLayerRef && blueTrianglesLayerRef.visible) {
        html += '<div style="margin-bottom:8px;"><span style="font-weight:bold; color:#003366;">AWT + Water treaters</span><br>';
        html += `<span style='display:inline-block; width:0; height:0; border-left:9px solid transparent; border-right:9px solid transparent; border-bottom:18px solid #0074D9; margin-right:6px; vertical-align:middle;'></span> <span style='vertical-align:middle;'></span><br>`;
        html += '</div>';
      }
      if (yellowTrianglesLayerRef && yellowTrianglesLayerRef.visible) {
        html += '<div style="margin-bottom:8px;"><span style="font-weight:bold; color:#bfa800;">Companies for linked-in search</span><br>';
        html += `<span style='display:inline-block; width:0; height:0; border-left:9px solid transparent; border-right:9px solid transparent; border-bottom:18px solid #FFFF00; margin-right:6px; vertical-align:middle; border-bottom-color:#FFFF00; border-width:0 9px 18px 9px;'></span> <span style='vertical-align:middle;'></span><br>`;
        html += '</div>';
      }
      if (countiesLayerRef && countiesLayerRef.visible) {
        html += '<div style="margin-bottom:8px;"><span style="font-weight:bold; color:#222;">US Counties</span><br>';
        let renderer = countiesLayerRef.renderer;
        let steps = [];
        if (renderer && renderer.uniqueValueInfos && renderer.uniqueValueInfos.length > 0) {
          let countMap = {};
          renderer.uniqueValueInfos.forEach(info => {
            let match = info.label && info.label.match(/\((\d+)\)$/);
            let count = match ? parseInt(match[1]) : 0;
            if (!isNaN(count)) {
              if (!countMap[count]) countMap[count] = [];
              countMap[count].push(info.symbol.color);
            }
          });
          let sortedCounts = Object.keys(countMap).map(Number).sort((a,b)=>a-b);
          let displayCounts = [];
          if (sortedCounts.length > 6) {
            let n = sortedCounts.length;
            displayCounts = [sortedCounts[0]];
            for (let i=1; i<=4; i++) {
              let idx = Math.round(i*n/5)-1;
              if (idx < 0) idx = 0;
              if (idx >= n) idx = n-1;
              let val = sortedCounts[idx];
              if (!displayCounts.includes(val)) displayCounts.push(val);
            }
            if (!displayCounts.includes(sortedCounts[n-1])) displayCounts.push(sortedCounts[n-1]);
            displayCounts = Array.from(new Set(displayCounts)).sort((a,b)=>a-b);
          } else {
            displayCounts = sortedCounts;
          }
          displayCounts.forEach(count => {
            let color = countMap[count][0];
            let rgb = Array.isArray(color) ? `rgb(${color[0]},${color[1]},${color[2]})` : color;
            html += `<span style='display:inline-block; width:18px; height:18px; background:${rgb}; border:1px solid #000; margin-right:6px; vertical-align: middle;'></span> <span style='vertical-align: middle;'>${count} professional${count!==1?'s':''}</span><br>`;
          });
        } else {
          html += `<span style='display:inline-block; width:18px; height:18px; background:rgba(240,240,240,0.1); border:1px solid #000; margin-right:6px; vertical-align:middle;'></span> <span style='vertical-align:middle;'>No Data</span><br>`;
        }
        html += '</div>';
      }
      if (html === '' || html.indexOf('margin-bottom:8px;') === -1) {
        html += '<div style="color:#888;">No active layers to show in legend.</div>';
      }
      legendContent.innerHTML = html;
    }

    legendBtn.addEventListener("click", function() {
      manipulatorPane.style.display = 'flex';
      updateLegend();
    });


    document.getElementById("chkProfessionals").addEventListener("change", function(e) {
      if (professionalsLayerRef) professionalsLayerRef.visible = e.target.checked;
      updateLegend();
    });
    document.getElementById("chkCounties").addEventListener("change", function(e) {
      if (countiesLayerRef) countiesLayerRef.visible = e.target.checked;
      updateLegend();
    });
    document.getElementById("chkBlueTriangles").addEventListener("change", function(e) {
      if (blueTrianglesLayerRef) blueTrianglesLayerRef.visible = e.target.checked;
      updateLegend();
    });
    document.getElementById("chkYellowTriangles").addEventListener("change", function(e) {
      if (yellowTrianglesLayerRef) yellowTrianglesLayerRef.visible = e.target.checked;
      updateLegend();
    });
  }); 
  </script>
</body>
</html>